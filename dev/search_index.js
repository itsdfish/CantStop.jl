var documenterSearchIndex = {"docs":
[{"location":"api/#Required","page":"API","title":"Required","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The API requires you to create a subtype of AbstractPlayer with extensions of the methods below.","category":"page"},{"location":"api/#Types","page":"API","title":"Types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"AbstractPlayer","category":"page"},{"location":"api/#CantStop.AbstractPlayer","page":"API","title":"CantStop.AbstractPlayer","text":"AbstractPlayer\n\nAn abstract type for a player. Subtypes of AbstractPlayer must have the fields described below.\n\nFields\n\nid::Symbol: player id\npieces::Vector{Symbol}: a vector of 11 pieces where each piece has the value id. \npiece_reserve::Vector{Symbol}: an optional vector for keeping track of pieces which will replace runners unless a bust occurs\n\nIn addition, for a subtype MyPlayer <: AbstractPlayer, the API requires the following constructor to ensure  the correct number of pieces are provided. \n\nConstructor\n\nMyPlayer(;id, pieces=fill(id, 11)) = MyPlayer(id, pieces)\n\n\n\n\n\n","category":"type"},{"location":"api/#Methods","page":"API","title":"Methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The API requires one to define the following methods for each custom player type. ","category":"page"},{"location":"api/","page":"API","title":"API","text":"roll_again\nselect_runners\npostbust_cleanup!\npoststop_cleanup!","category":"page"},{"location":"api/#CantStop.roll_again","page":"API","title":"CantStop.roll_again","text":"roll_again(Game::AbstractGame, player::AbstractPlayer)\n\nDuring the decision phase, decide whether to take a chance to advance the runners, or set your pieces in  the current location of the runners. \n\nArguments\n\ngame::AbstractGame: an abstract game object for Can't Stop. The object is a copy, which means it is safe to    modify.\nplayer::AbstractPlayer: an subtype of a abstract player\n\nReturns\n\ndecision::Bool: true if take chance, false otherwise\n\n\n\n\n\n","category":"function"},{"location":"api/#CantStop.select_runners","page":"API","title":"CantStop.select_runners","text":"select_runners(Game::AbstractGame, player::AbstractPlayer, options)\n\nDuring the selection phase, select runners based on the outcome of a dice roll. \n\nArguments\n\ngame::AbstractGame: an abstract game object for Can't Stop. The object is a copy, which means it is safe to    modify.\nplayer::AbstractPlayer: an subtype of a abstract player\noptions: a vector of columns that can be selected based on outcome of rolling dice\n\nReturns\n\nc_idx::Vector{Int}: a vector of selected column indices for moving runner\n\n\n\n\n\n","category":"function"},{"location":"api/#CantStop.postbust_cleanup!","page":"API","title":"CantStop.postbust_cleanup!","text":"postbust_cleanup!(Game::AbstractGame, player::AbstractPlayer)\n\nPerforms cleanup and book keeping after a \"bust\" (i.e., a roll that does not provide a valid move).\n\nArguments\n\ngame::AbstractGame: an abstract game object for Can't Stop. The object is a copy, which means it is safe to    modify.\nplayer::AbstractPlayer: an subtype of a abstract player\n\nReturns\n\nnothing\n\n\n\n\n\n","category":"function"},{"location":"api/#CantStop.poststop_cleanup!","page":"API","title":"CantStop.poststop_cleanup!","text":"poststop_cleanup!(Game::AbstractGame, player::AbstractPlayer)\n\nPerforms cleanup and book keeping after deciding to stop rolling during the decision phase.\n\nArguments\n\ngame::AbstractGame: an abstract game object for Can't Stop. The object is a copy, which means it is safe to    modify.\nplayer::AbstractPlayer: an subtype of a abstract player\n\nReturns\n\nnothing\n\n\n\n\n\n","category":"function"},{"location":"api/#Optional-Types","page":"API","title":"Optional Types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"It is possible to create variations of the game by creating a new subtype of AbstractGame and  defining new internal methods as needed. ","category":"page"},{"location":"api/","page":"API","title":"API","text":"AbstractGame","category":"page"},{"location":"api/#CantStop.AbstractGame","page":"API","title":"CantStop.AbstractGame","text":"AbstractGame\n\nAn abstract game type for Can't Stop. \n\nThe following fields are required in order to work with default methods: \n\nFields\n\ndice::Dice: an object resepresenting four dice \npieces::Dict{Symbol,Vector{Symbol}}: inactive pieces for each player: player_id -> pieces\ncolumns_won::Vector{Int}: a vector of indices for columns won\nmax_rows::Dict{Int,Int}: maximum number of rows for each column\nplayers_won::Dict{Int,Symbol}: indicates which player won a given column. A value of :_ indicates no    player has won the column\n\n\n\n\n\n","category":"type"},{"location":"api/#Available-Types","page":"API","title":"Available Types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Game","category":"page"},{"location":"api/#CantStop.Game","page":"API","title":"CantStop.Game","text":"Game{P<:AbstractPiece} <: AbstractGame\n\nThe default game object for CantStop. \n\nFields\n\ndice::Dice: an object resepresenting four dice \npieces::Dict{Symbol,Vector{Symbol}}: inactive pieces for each player: player_id -> pieces\ncolumns_won::Vector{Int}: a vector of indices for columns won\nmax_rows::Dict{Int,Int}: maximum number of rows for each column\nplayers_won::Dict{Int,Symbol}: indicates which player won a given column. A value of :_ indicates no    player has won the column\n\nConstructor\n\nGame(;dice=Dice(), piece_type=Piece)\n\n\n\n\n\n","category":"type"},{"location":"api/#Utilities","page":"API","title":"Utilities","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The following methods might be helpful for defining the required methods above.","category":"page"},{"location":"api/","page":"API","title":"API","text":"simulate!\nget_winner","category":"page"},{"location":"api/#CantStop.simulate!","page":"API","title":"CantStop.simulate!","text":"simulate!(game::AbstractGame, players)\n\nSimulate CantStop until a player has won. \n\nArguments\n\ngame::AbstractGame: an abstract game object for Can't Stop\nplayer::AbstractPlayer: an subtype of a abstract player\n\n\n\n\n\n","category":"function"},{"location":"api/#CantStop.get_winner","page":"API","title":"CantStop.get_winner","text":"get_winner(game::AbstractGame)\n\nReturns the winner of the game. \n\nArguments\n\ngame::AbstractGame: an abstract game object for Can't Stop\n\n\n\n\n\n","category":"function"},{"location":"internal_methods/","page":"Internal Methods","title":"Internal Methods","text":"Modules = [CantStop]\nOrder   = [:type, :function]\nPublic = false","category":"page"},{"location":"internal_methods/#CantStop.Dice","page":"Internal Methods","title":"CantStop.Dice","text":"Dice\n\nAn object for rolling dice. \n\nFields\n\nn::Int: number of rolls \nsides::Int: number of sides per die\n\nConstructors\n\nDice(4, 6)\nDice(;n=4, sides=6)\n\n\n\n\n\n","category":"type"},{"location":"internal_methods/#CantStop.check_winners!-Tuple{AbstractGame, AbstractPlayer}","page":"Internal Methods","title":"CantStop.check_winners!","text":"check_winners!(game::AbstractGame, player::AbstractPlayer)\n\nFollowing a stop decision, identifies whether player conquered any columns. Conquered columns  are tracked in the fields columns_won and players_won of the game object. \n\ngame::AbstractGame: an abstract game object for Can't Stop\nplayer::AbstractPlayer: an subtype of a abstract player\n\n\n\n\n\n","category":"method"},{"location":"internal_methods/#CantStop.decision_phase!-Tuple{AbstractGame, AbstractPlayer}","page":"Internal Methods","title":"CantStop.decision_phase!","text":"decision_phase!(game::AbstractGame, player::AbstractPlayer)\n\nImplements the decision phase in which the player decides to roll the dice for the possibility of  moving the runners. The two methods named decide! are called during this phase.\n\nArguments\n\ngame::AbstractGame: an abstract game object for Can't Stop\nplayer::AbstractPlayer: an subtype of a abstract player\n\n\n\n\n\n","category":"method"},{"location":"internal_methods/#CantStop.handle_bust!-Tuple{AbstractGame, AbstractPlayer}","page":"Internal Methods","title":"CantStop.handle_bust!","text":"set_runners_false!(game::AbstractGame, player)\n\nArguments\n\ngame::AbstractGame: an abstract game object for Can't Stop\nplayer::AbstractPlayer: an subtype of a abstract player\n\n\n\n\n\n","category":"method"},{"location":"internal_methods/#CantStop.handle_stop!-Tuple{AbstractGame, AbstractPlayer}","page":"Internal Methods","title":"CantStop.handle_stop!","text":"set_runners_false!(game::AbstractGame, player)\n\nArguments\n\ngame::AbstractGame: an abstract game object for Can't Stop\nplayer::AbstractPlayer: an subtype of a abstract player\n\n\n\n\n\n","category":"method"},{"location":"internal_methods/#CantStop.initialize_pieces!-Tuple{AbstractGame, AbstractPlayer}","page":"Internal Methods","title":"CantStop.initialize_pieces!","text":"set_runners_false!(game::AbstractGame, player)\n\nArguments\n\ngame::AbstractGame: an abstract game object for Can't Stop\nplayer::AbstractPlayer: an subtype of a abstract player\n\n\n\n\n\n","category":"method"},{"location":"internal_methods/#CantStop.is_bust-Tuple{AbstractGame, Any}","page":"Internal Methods","title":"CantStop.is_bust","text":"is_bust(game::AbstractGame, options)\n\nChecks whether a dice roll is a bust i.e., does not allow a valid move. \n\nArguments\n\ngame::AbstractGame: an abstract game object for Can't Stop\noptions: a vector of column indices corresponding to possible choices\n\n\n\n\n\n","category":"method"},{"location":"internal_methods/#CantStop.is_playing-Tuple{AbstractGame}","page":"Internal Methods","title":"CantStop.is_playing","text":"is_playing(game::AbstractGame)\n\nArguments\n\ngame::AbstractGame: an abstract game object for Can't Stop\n\n\n\n\n\n","category":"method"},{"location":"internal_methods/#CantStop.list_options-Tuple{Any, Any}","page":"Internal Methods","title":"CantStop.list_options","text":"list_sums(outcome)\n\nLists all unique sum of combinations of the outcome of rolling dice\n\nArguments\n\ngame::AbstractGame: an abstract game object for Can't Stop\noutcome: the results of rolling the dice\n\n\n\n\n\n","category":"method"},{"location":"internal_methods/#CantStop.list_sums-Tuple{Any}","page":"Internal Methods","title":"CantStop.list_sums","text":"list_sums(outcome)\n\nLists all unique sum of combinations of the outcome of rolling dice\n\nArguments\n\noutcome: the results of rolling the dice\n\n\n\n\n\n","category":"method"},{"location":"internal_methods/#CantStop.move!-Tuple{AbstractGame, Any, Any}","page":"Internal Methods","title":"CantStop.move!","text":"move!(game::AbstractGame, id, r_idx)\n\nMove runner to location determined by column and row index\n\nArguments\n\ngame::AbstractGame: an abstract game object\nid: the id of the player \nc_idx: column index of position \n\n\n\n\n\n","category":"method"},{"location":"internal_methods/#CantStop.play_round!-Tuple{AbstractGame, AbstractPlayer}","page":"Internal Methods","title":"CantStop.play_round!","text":"play_round!(game::AbstractGame, player::AbstractPlayer)\n\nPlay one round with a specified player. During each iteration of a round, the player makes two decision_phase\n\ndecide whether to roll the dice\ndecide which pairs to sum to move runners\n\nArguments\n\ngame::AbstractGame: an abstract game object for Can't Stop\nplayer::AbstractPlayer: an subtype of a abstract player\n\n\n\n\n\n","category":"method"},{"location":"internal_methods/#CantStop.return_to_start_position!-Tuple{AbstractGame, AbstractPlayer}","page":"Internal Methods","title":"CantStop.return_to_start_position!","text":"return_to_start_position!(game::AbstractGame, player::AbstractPlayer)\n\nArguments\n\ngame::AbstractGame: an abstract game object for Can't Stop\nplayer::AbstractPlayer: an subtype of a abstract player\n\n\n\n\n\n","category":"method"},{"location":"internal_methods/#CantStop.set_runners_false!-Tuple{AbstractGame, AbstractPlayer}","page":"Internal Methods","title":"CantStop.set_runners_false!","text":"set_runners_false!(game::AbstractGame, player)\n\nArguments\n\ngame::AbstractGame: an abstract game object for Can't Stop\nplayer::AbstractPlayer: an subtype of a abstract player\n\n\n\n\n\n","category":"method"},{"location":"internal_methods/#CantStop.set_status!-Tuple{AbstractGame, Any, Any}","page":"Internal Methods","title":"CantStop.set_status!","text":"set_status!(game::AbstractGame, id, c_idx)\n\nMove runner to location determined by column and row index\n\nArguments\n\ngame::AbstractGame: an abstract game object\nid: the id of the player \nc_idx: column index of position \n\n\n\n\n\n","category":"method"},{"location":"internal_methods/#CantStop.validate_choice-Tuple{Vector{Vector{Int64}}, Vector{Int64}}","page":"Internal Methods","title":"CantStop.validate_choice","text":"validate_choice(options::Vector{Vector{Int}}, choice::Vector{Int})\n\nDetermine whether a player made a valid choice.\n\nArguments\n\noptions: a vector of options \nchoice: the element from options selected by the player\n\n\n\n\n\n","category":"method"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"using CantStop\nimport CantStop: postbust_cleanup!\nimport CantStop: poststop_cleanup!\nimport CantStop: roll_again\nimport CantStop: select_runners","category":"page"},{"location":"basic_usage/#Introduction","page":"Basic Usage","title":"Introduction","text":"","category":"section"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"In this tutorial, we provide a basic example to illustrate how to use the API for Cantstop.jl. The decision strategy of the example player is designed to be as simple as possible for illustrative purposes. As such, the strategy is to select an avaiable option at random. ","category":"page"},{"location":"basic_usage/#Example","page":"Basic Usage","title":"Example","text":"","category":"section"},{"location":"basic_usage/#Dependencies","page":"Basic Usage","title":"Dependencies","text":"","category":"section"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"The first step is to load the dependencies. In this simple example, the only dependency we need is CantStop, which is loaded via the using keyword. In addition, we must import a total of five methods using the keyword import. By importing the methods, we can define a version of each method which works with our player type. ","category":"page"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"using CantStop\nimport CantStop: postbust_cleanup!\nimport CantStop: poststop_cleanup!\nimport CantStop: roll_again\nimport CantStop: select_runners","category":"page"},{"location":"basic_usage/#Make-Player-Type","page":"Basic Usage","title":"Make Player Type","text":"","category":"section"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"The API for CantStop requires you to define your own player type, which is a subtype of AbstractPlayer. The example below contains three required fields: id, which is a unique identifier. Optionally, you may add other fields to your custom player type as needed.","category":"page"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"struct Player <: AbstractPlayer\n    id::Symbol\nend\n\nPlayer(;id) = Player(id)","category":"page"},{"location":"basic_usage/#Required-Methods","page":"Basic Usage","title":"Required Methods","text":"","category":"section"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"The API requires four methods to be defined for each custom type: roll_again, select_runners, postbust_cleanup, and poststop_cleanup. The first two methods concern the decision making mechanics of the player, and thus, must return required information to play the game. As illustrated below, the last two methods must also be defined, but can be blank because the interal functions do not process. The purpose is to provide an entry point to optionally update the internal state of the player following a bust or decision to stop. ","category":"page"},{"location":"basic_usage/#select_runners","page":"Basic Usage","title":"select_runners","text":"","category":"section"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"Each round begins with an initial roll of the dice and a decision to select runners to move. The function requires the following arguments:","category":"page"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"game::AbstractGame: a copy of the game object for Can't Stop\nplayer::Player: a n object for your player type \noptions: a copy of a vector of runners which can advance, e.g., [[1,2],[3],[4]]","category":"page"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"The method must return one element from the vector of options, e.g., [1,2]. In the simple example below, the player selects an option randomly with equal probability. ","category":"page"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"select_runners(game::AbstractGame, player::Player, options) = rand(options)","category":"page"},{"location":"basic_usage/#roll_again","page":"Basic Usage","title":"roll_again","text":"","category":"section"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"After moving runners, the player is presented with a decision to roll again for a chance to further advance the runners, or to stop and keep the runners in their current position. The player can make a decision based on the state of the game, which is provided in the game object. To make the player simple, it decides to continue stop with equal probability. ","category":"page"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"roll_again(game::AbstractGame, player::Player) = rand(Bool)","category":"page"},{"location":"basic_usage/#postbust_cleanup","page":"Basic Usage","title":"postbust_cleanup","text":"","category":"section"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"The function postbust_cleanup provides an optional entry point update the state of the player following a bust. Using this function might be helpful for a player which learns from experience. For the purposes of our simple player, postbust_cleanup is not necessary. Thus, it simply returns nothing. ","category":"page"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"postbust_cleanup!(game::AbstractGame, player::Player) = nothing","category":"page"},{"location":"basic_usage/#poststop_cleanup","page":"Basic Usage","title":"poststop_cleanup","text":"","category":"section"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"The function poststop_cleanup provides an optional entry point update the state of the player after deciding to stop rolling the dice.  Again, poststop_cleanup might be useful for some custom players, but is not necessary for this simple example. As before, this function simply returns nothing. ","category":"page"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"poststop_cleanup!(game::AbstractGame, player::Player) = nothing","category":"page"},{"location":"basic_usage/#Run-Simulation","page":"Basic Usage","title":"Run Simulation","text":"","category":"section"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"Now that we defined a custom player type and the four required methods, we can now simulate the game. Below, we begin by generating an instance of the default Game object. Next, we define a vector of two players with unique ids. Finally, we use simulate! so the two players play Can't Stop and then call get_winner to identify the winner. ","category":"page"},{"location":"basic_usage/","page":"Basic Usage","title":"Basic Usage","text":"game = Game()\nplayers = [Player(id=:p1), Player(id=:p2)]\nsimulate!(game, players)\nget_winner(game)","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The purpose of this documentation is to describe the API for developing bots or models which play the board game Can't Stop. CantStop.jl provides two key features: (1) abstract types and methods which can be extended to implement bots with custom strategies, and (2) internal methods which can be extended to develop variations of Can't Stop.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"There are two methods for installing the package. Option 1 is to install without version control. In the REPL, use ] to switch to the package mode and enter the following:","category":"page"},{"location":"","page":"Home","title":"Home","text":"add https://github.com/itsdfish/CantStop.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"Option 2 is to install via a custom registry. The advantage of this approach is that you have more control over version control, expecially if you are using a project-specfic environment. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Install the registry using the directions found here.\nAdd the package by typing ] into the REPL and then typing (or pasting):","category":"page"},{"location":"","page":"Home","title":"Home","text":"add CantStop","category":"page"},{"location":"#Basic-Rules","page":"Home","title":"Basic Rules","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In Can't Stop, the goal is to advance pieces and ultimately capture three columns. A column is capture by being the first to move a piece to the end of the column. As shown below, the board contains 11 columns labeled 2 through 12, which correspond to possible values for the sum of two six-sided dice. Sums corresponding to columns near the center have a higher probability, but also require more moves to capture. During a round, a player repeatedly makes two decisions:","category":"page"},{"location":"","page":"Home","title":"Home","text":"roll dice to have a chance of advancing runners\nselect which runners to advance based on the outcome of four dice","category":"page"},{"location":"","page":"Home","title":"Home","text":"A player can have a maximum of 3 runners on the board during each round. A runner is an active piece which can be moved if its column number is equal to the sum of a pair of dice. If the outcome of rolling the dice does not allow a runner to move (i.e., there are no sums which equal a column number of a runner), a \"bust\" occurs, meaning the player must return the piece to the starting position at the beginning of the round. If the player decides not to roll the dice, the runners stay at thier current position. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: image info)","category":"page"}]
}
